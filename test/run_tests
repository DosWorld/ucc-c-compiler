#!/usr/bin/perl
use strict;

my $ucc = undef;
my @expected_fails;
my @skips;

sub interrupt
{
	exit 25
}

sub basename
{
	my $f = shift;
	return $1 if $f =~ m;/([^/]+)$;;
	return $f;
}

sub usage
{
	print STDERR "Usage: $0 [-q | -v] [-i ignore-file] [--ucc=...] [tests...]\n";
	print STDERR "Specify UCC_CHECK_SKIP=path1,path2,... to skip paths\n";
	exit 2;
}

sub read_ignores
{
	my $f = shift;
	open F, '<', $f or die "open $f: $!";

	my @f =
		grep { length }
		map { s/ *#.*//; $_ }
		map { chomp $_; $_ } <F>;

	close F;
	return @f;
}

sub test
{
	my %args = @_; # keys = file, output, verbose

	my $pid = fork();
	if($pid == 0){
		# ./test.pl -v "$1" < /dev/null > "$2" 2>&1
		open STDIN, '</dev/null' or die;
		open STDOUT, '>', $args{output} or die;
		open STDERR, '>&STDOUT' or die;

		my @args = @args{file};
		unshift @args, '-v' if $args{verbose};
		unshift @args, "--ucc=$ucc" if defined($ucc);
		exec './test.pl', @args;
		die "exec: $!";
	}
	if(wait() != $pid){
		die "bad wait return? $!";
	}

	my $r = $?;
	return $r;
}

sub cat_indent_file
{
	my $f = shift;
	open F, '<', $f or die "open $f: $!\n";
	print "\t$_" while <F>;
	close F;
}

sub in_array
{
	my $f = shift;
	for(@_){
		if(index($f, $_) != -1){
			return 1;
		}
	}
	return 0;
}

sub file_status
{
	my $f = shift;

	return "skip" if in_array($f, @skips);
	return "fail" if in_array($f, @expected_fails);

	return "pass";
}

$SIG{INT} = \&interrupt;

my $verbose = 0;
my $quiet;
my $ign_file = undef;
my @tests;

if($ENV{CI}){
	$quiet = 0;
}elsif(-t 1){
	$quiet = 1;
}else{
	$quiet = 0;
}

for(my $i = 0; $i < @ARGV; $i++){
	if($ARGV[$i] eq '-v'){
		$verbose = 1;
		$quiet = 0;
	}elsif($ARGV[$i] eq '-q'){
		$quiet = 1;
		$verbose = 0;
	}elsif($ARGV[$i] eq '-i'){
		my $f = $ARGV[++$i];
		usage() unless $f;
		$ign_file = $f;
	}elsif($ARGV[$i] =~ /^--ucc=(.+)$/){
		$ucc = $1;

	}else{
		push @tests, $ARGV[$i];
	}
}

push @expected_fails, read_ignores($ign_file) if $ign_file;
push @skips, split /,/, $ENV{UCC_CHECK_SKIP};

my $env_tmpdir = $ENV{TMPDIR} || '/tmp';
my $tdir = "$env_tmpdir/ucc.test/";
my @unlinks;
push @unlinks, $tdir;
if(not -d $tdir and not mkdir($tdir)){
	die "mkdir: $!";
}
$ENV{UCC_TESTDIR} = $tdir;

my $ec = 0;

sub find_tests
{
	# DFS
	my @found;
	for(my $i = 0; $i < @_; $i++){
		$_ = $_[$i];
		if(-d $_){
			push @found, find_tests(glob "$_/*");
		}elsif($_ =~ /\.c$/){
			push @found, $_;
		}
	}
	return @found;
}

my @test_files = find_tests(@tests);
die "$0: no tests\n" unless @test_files;

for my $f (@test_files){
	chomp($f);

	print "$0: $f\n" if $verbose;

	my %args = (
		file => $f,
		output => "$tdir/" . basename($f),
		verbose => $verbose
	);

	my $status = file_status($f);
	my $rc = 2;
	if(!($status eq 'skip')){
		$rc = test(%args);

		if($rc & 127){
			die "test caught signal " . ($rc & 127) . "\n";
		}
		$rc >>= 8; # exit code
	}

	my $desc;
	my $failed = 0;

	if($rc == 1){
		$desc = 'fail';
		$failed = 1;
	}elsif($rc == 2){
		$desc = 'skip';
	}else{
		$desc = 'pass';
	}

	my $should_fail = ($status eq 'fail');

	print "$desc"
	. ($should_fail ? ' (fail expected)' : '')
	. ": $f";

	if($failed != $should_fail){
		print "\n";

		$ec = 1;
		# dump output
		cat_indent_file($args{output});
	}elsif($quiet){
		# clear to eol, move cursor to start
		print "\e[K\r";
	}else{
		print "\n";
	}
}

END
{
	my $r = $?;
	system('rm', '-r', @unlinks) if @unlinks;
	$? = $r;
}

exit $ec;
